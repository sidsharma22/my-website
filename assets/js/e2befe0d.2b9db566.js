"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[919],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>m});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=i.createContext({}),l=function(e){var t=i.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},h=function(e){var t=l(e.components);return i.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),d=l(n),m=a,f=d["".concat(c,".").concat(m)]||d[m]||u[m]||o;return n?i.createElement(f,r(r({ref:t},h),{},{components:n})):i.createElement(f,r({ref:t},h))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var l=2;l<o;l++)r[l]=n[l];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2297:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var i=n(7462),a=(n(7294),n(3905));const o={slug:"second-post",title:"Why scaling helps the cost  function to converge faster?",authors:["sid"],tags:["Gradient Descent","Cost Function","ML"]},r=void 0,s={permalink:"/my-website/blog/second-post",source:"@site/blog/2022-11-08-GradientDescent.mdx",title:"Why scaling helps the cost  function to converge faster?",description:"TL;DR: Scaling the input features, causes the gradient of the cost to converge faster.",date:"2022-11-08T00:00:00.000Z",formattedDate:"November 8, 2022",tags:[{label:"Gradient Descent",permalink:"/my-website/blog/tags/gradient-descent"},{label:"Cost Function",permalink:"/my-website/blog/tags/cost-function"},{label:"ML",permalink:"/my-website/blog/tags/ml"}],readingTime:2.785,hasTruncateMarker:!0,authors:[{name:"Sidharth Sharma",title:"Student @ Carnegie Mellon University",url:'https://github.com/sidsharma22/"',imageURL:"https://avatars.githubusercontent.com/u/37993073?s=400&u=9c80d5d567d2d57fe699a018b48a15221640ff4e&v=4",key:"sid"}],frontMatter:{slug:"second-post",title:"Why scaling helps the cost  function to converge faster?",authors:["sid"],tags:["Gradient Descent","Cost Function","ML"]}},c={authorsImageUrls:[void 0]},l=[{value:"Introduction",id:"introduction",level:3},{value:"Cost function",id:"cost-function",level:3},{value:"How do gradients work?",id:"how-do-gradients-work",level:3},{value:"Use of Gradients in Machine Learning",id:"use-of-gradients-in-machine-learning",level:3},{value:"Gradient of an ellipse vs circle",id:"gradient-of-an-ellipse-vs-circle",level:3},{value:"Impact of scaling",id:"impact-of-scaling",level:3}],h={toc:l};function u(e){let{components:t,...o}=e;return(0,a.kt)("wrapper",(0,i.Z)({},h,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"TL;DR: Scaling the input features, causes the gradient of the cost to converge faster."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"img alt",src:n(5173).Z,width:"275",height:"268"})),(0,a.kt)("h3",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"While running a machine learning experiment using linear regression, I noticed that the batch gradient descent algorithm converges faster when the data is scaled. Since, we know the effects of scaling helps in models like KNN where the magnitude of each observation plays a very important role, but why is convergence affected  in case of batch-gradient descent? Why was scaling having such a big impact?\nIn the experiment if I do not scale the features the algorithm does not converge in a fixed number of steps. After scaling, the algorithm converges in half the number of steps initially used!\nFirst, let\u2019s look at the cost function that is in this experiment."),(0,a.kt)("h3",{id:"cost-function"},"Cost function"),(0,a.kt)("p",null,"I used residual sum of squares error as the cost function in this experiment.\nRss = ((theta_0 + theta_1*x) - y )^2\nThis will give us an ellipse equation. But if we scale our input value (x) such that the values are between 0 and 1.  The equation smooths to look like a circle, when the equation is plotted with theta_0 on the x-axis and theta_1 on the y_axis. Moving forward, remember how scaling the input smooths the contour. "),(0,a.kt)("h3",{id:"how-do-gradients-work"},"How do gradients work?"),(0,a.kt)("p",null,"The gradient of a multivariate  function gives us the direction where the function increases the fastest and its magnitude gives us the rate of increase. For a more intuitive example, think of burning an incense stick and then observing its smoke. In three dimensional space the smoke will move in one direction(xmax, ymax, zmax) faster as compared to other directions, and that is the gradient!"),(0,a.kt)("h3",{id:"use-of-gradients-in-machine-learning"},"Use of Gradients in Machine Learning"),(0,a.kt)("p",null,"All the parametric models in machine learning have a cost function. We try to find the minima of that cost function as we want our model to learn the relationship between our input data and the output label. With the help of gradients  we know how to calculate the direction of fastest increase in function. We use this technique to get the direction in which the cost of our system increases the most and then move in the opposite direction. Why the opposite? Because we want to reach the minimum point of this increasing function. Why the minimum? The minimum point will give us the minimum cost! "),(0,a.kt)("h3",{id:"gradient-of-an-ellipse-vs-circle"},"Gradient of an ellipse vs circle"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"img alt",src:n(1791).Z,width:"627",height:"244"}),"\nOne of the things we should remember in order to understand why scaling is required is that the gradient of an ellipse does not point to its center, whereas in the case of a circle the gradient will always point to the center. At the center lies the point where the cost is minimum."),(0,a.kt)("h3",{id:"impact-of-scaling"},"Impact of scaling"),(0,a.kt)("p",null,"When we scale the inputs and squash the values between 0 - 1. This automatically smoothes the contours of our cost function to be more circular. Normalizing will result in a cost function with less elliptical and more 'circular' contours. This gives us two advantages, the gradient would converge faster as its natural direction would be towards the center and we could increase the step size or learning rate \u201calpha\u201d in this case to reach the minima even quicker, as there would be less zig-zag movement by the gradient vector to find the minima."))}u.isMDXComponent=!0},5173:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/GD-1-68a3d4ec5a1098f5b9e3929d2bde566e.png"},1791:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/GD-2-e1be80e564ba129a81f75659ef6089d9.png"}}]);